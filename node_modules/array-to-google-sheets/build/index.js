"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
require("./types");
// tslint:disable-next-line
var google_spreadsheet_1 = __importDefault(require("google-spreadsheet"));
var ArrayToGoogleSheets = /** @class */ (function () {
    function ArrayToGoogleSheets(docKey, creds) {
        this.docKey = docKey;
        this.creds = creds;
        if (typeof creds === "string") {
            // this is file, convert to json
            this.credsJson = this.importJson(creds);
        }
        else {
            this.credsJson = creds;
        }
        this.doc = new google_spreadsheet_1.default(this.docKey);
    }
    // region public methods: utils
    ArrayToGoogleSheets.prototype.convertColToAlphabet = function (num) {
        var char = (10 + (num - 1) % 26).toString(36).toUpperCase();
        return num > 0 ? this.convertColToAlphabet((num - 1) / 26 | 0) + char : "";
    };
    ArrayToGoogleSheets.prototype.convertWid2gid = function (wid) {
        var widVal = wid.length > 3 ? wid.substr(1) : wid;
        var xorVal = wid.length > 3 ? 474 : 31578;
        return parseInt(String(widVal), 36) ^ xorVal;
    };
    ArrayToGoogleSheets.prototype.importJson = function (file) {
        var data = fs_1.default.readFileSync(file).toString();
        return JSON.parse(data);
    };
    ArrayToGoogleSheets.prototype.getUrlObject = function (wid) {
        var gid = this.convertWid2gid(wid);
        var url = "https://docs.google.com/spreadsheets/d/" + this.docKey + "/edit#gid=" + gid;
        return { url: url, gid: gid };
    };
    ArrayToGoogleSheets.prototype.formatFormula = function (formulaFormat, cells, currentRow, currentCol) {
        var _this = this;
        if (!Array.isArray(cells)) {
            return formulaFormat;
        }
        var arr = cells.map(function (cell) {
            var col = cell.col === "this" ? currentCol : cell.col;
            var row = cell.row === "this" ? currentRow : cell.row;
            return (col > 0 ? _this.convertColToAlphabet(col) : "") + (row > 0 ? row : "");
        });
        return formulaFormat.replace(/%(\d+)/g, function (_, m) {
            return arr[--m];
        });
    };
    // endregion
    // region public methods
    ArrayToGoogleSheets.prototype.updateGoogleSheetsData = function (sheet, values, options) {
        return __awaiter(this, void 0, void 0, function () {
            var rowCount, colCount, cells, myCells, updatedCells;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        rowCount = Math.max(options.minRow, values.length) + options.margin;
                        colCount = Math.max(options.minCol, values.reduce(function (a, b) { return Math.max(a, b.length); }, 0)) + options.margin;
                        // apply options
                        if (!options.resize) {
                            rowCount = sheet.rowCount;
                            colCount = sheet.colCount;
                        }
                        return [4 /*yield*/, this._resizeSheet(sheet, rowCount, colCount)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this._getCells(sheet, rowCount)];
                    case 2:
                        cells = _a.sent();
                        myCells = [];
                        updatedCells = [];
                        // process the cells
                        cells.forEach(function (cell) {
                            if (!myCells[cell.row - 1]) {
                                myCells[cell.row - 1] = [];
                            }
                            myCells[cell.row - 1].push(cell);
                            // clear all the cells's value
                            if (options.clear) {
                                cell.value = "";
                            }
                        });
                        // update the cell
                        values.forEach(function (list, i) {
                            list.forEach(function (value, j) {
                                if (myCells[i] && myCells[i][j]) {
                                    if (!isNaN(parseFloat(value)) && isFinite(value)) {
                                        myCells[i][j].numericValue = value;
                                    }
                                    else if (typeof value === "object") {
                                        myCells[i][j].formula = _this.formatFormula(value.formula, value.cells, i + 1, j + 1);
                                    }
                                    else {
                                        myCells[i][j].value = value;
                                    }
                                    updatedCells.push(myCells[i][j]);
                                }
                            });
                        });
                        // update the cells
                        return [4 /*yield*/, this._updateCells(sheet, options.clear ? cells : updatedCells)];
                    case 3:
                        // update the cells
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    ArrayToGoogleSheets.prototype.updateGoogleSheets = function (sheetName, values, partialOption) {
        if (partialOption === void 0) { partialOption = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var option, docInfo, sheet;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        option = Object.assign({
                            minCol: 10,
                            minRow: 20,
                            margin: 2,
                            resize: true,
                            clear: true,
                        }, partialOption);
                        // the values array must be 2 dimensional
                        if (values.length > 0 && !Array.isArray(values[0])) {
                            throw new Error("Values must be 2 dimensional array.");
                        }
                        return [4 /*yield*/, this._getDocInfo()];
                    case 1:
                        docInfo = _a.sent();
                        sheet = docInfo.worksheets.find(function (x) { return x.title.toLowerCase() === sheetName.toLowerCase(); });
                        if (!!sheet) return [3 /*break*/, 3];
                        return [4 /*yield*/, this._addWorkSheet(sheetName)];
                    case 2:
                        sheet = _a.sent();
                        _a.label = 3;
                    case 3:
                        // make sure sheet exist
                        if (!sheet) {
                            throw new Error("Cannot create new sheet: " + sheetName);
                        }
                        // update array to the sheet
                        return [4 /*yield*/, this.updateGoogleSheetsData(sheet, values, option)];
                    case 4:
                        // update array to the sheet
                        _a.sent();
                        return [2 /*return*/, this.getUrlObject(sheet.id)];
                }
            });
        });
    };
    ArrayToGoogleSheets.prototype.getGoogleSheet = function (sheetName) {
        return __awaiter(this, void 0, void 0, function () {
            var data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getGoogleSheets([sheetName])];
                    case 1:
                        data = _a.sent();
                        if (sheetName in data) {
                            return [2 /*return*/, data[sheetName]];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ArrayToGoogleSheets.prototype.getGoogleSheetAsCsv = function (sheetName) {
        return __awaiter(this, void 0, void 0, function () {
            var data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getGoogleSheetsAsCsv([sheetName])];
                    case 1:
                        data = _a.sent();
                        if (sheetName in data) {
                            return [2 /*return*/, data[sheetName]];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ArrayToGoogleSheets.prototype.getGoogleSheets = function (sheetNames) {
        if (sheetNames === void 0) { sheetNames = []; }
        return __awaiter(this, void 0, void 0, function () {
            var docInfo, existingWorkSheets, existingSheetNames, promises, cellsList, result, _loop_1, i;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this._getDocInfo()];
                    case 1:
                        docInfo = _a.sent();
                        // get all sheet by default
                        if (sheetNames.length === 0) {
                            sheetNames = docInfo.worksheets.map(function (x) { return x.title; });
                        }
                        existingWorkSheets = docInfo.worksheets
                            .filter(function (x) { return sheetNames.includes(x.title); });
                        existingSheetNames = existingWorkSheets.map(function (x) { return x.title; });
                        promises = existingWorkSheets.map(function (x) { return _this._getCells(x, x.rowCount); });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 2:
                        cellsList = _a.sent();
                        result = {};
                        _loop_1 = function (i) {
                            var cells = cellsList[i];
                            var sheetName = sheetNames[i];
                            // turn into array2D
                            var array2d = [];
                            cells.forEach(function (cell) {
                                if (!array2d[cell.row - 1]) {
                                    array2d[cell.row - 1] = [];
                                }
                                array2d[cell.row - 1].push(cell.value);
                            });
                            // filter empty rows
                            array2d = array2d.filter(function (row) {
                                return row.filter(function (cell) { return cell.length > 0; }).length > 0;
                            });
                            // format and assign
                            result[sheetName] = array2d;
                        };
                        for (i = 0; i < cellsList.length; i++) {
                            _loop_1(i);
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    ArrayToGoogleSheets.prototype.getGoogleSheetsAsCsv = function (sheetNames) {
        if (sheetNames === void 0) { sheetNames = []; }
        return __awaiter(this, void 0, void 0, function () {
            var array2dObject, csvObject, _i, _a, _b, key, array2d, escapedArray2d;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getGoogleSheets(sheetNames)];
                    case 1:
                        array2dObject = _c.sent();
                        csvObject = {};
                        for (_i = 0, _a = Object.entries(array2dObject); _i < _a.length; _i++) {
                            _b = _a[_i], key = _b[0], array2d = _b[1];
                            escapedArray2d = array2d.map(function (row) {
                                return row.map(function (cell) {
                                    // we use double quote to wrap the strings if it has [,"\r\n]
                                    if (cell.match(/[,"\r\n]/)) {
                                        return "\"" + cell.replace(/"/g, "\"\"") + "\"";
                                    }
                                    return cell;
                                });
                            });
                            // format into csv
                            csvObject[key] = escapedArray2d.map(function (row) { return row.join(","); }).join("\r\n");
                        }
                        return [2 /*return*/, csvObject];
                }
            });
        });
    };
    // endregion
    // region private methods
    ArrayToGoogleSheets.prototype._getDocInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // connect to the service account
                    return [4 /*yield*/, new Promise(function (resolve, reject) {
                            _this.doc.useServiceAccountAuth(_this.credsJson, function (err) {
                                if (err) {
                                    return reject(err);
                                }
                                resolve();
                            });
                        })];
                    case 1:
                        // connect to the service account
                        _a.sent();
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                _this.doc.getInfo(function (err, docInfo1) {
                                    if (err) {
                                        return reject(err);
                                    }
                                    resolve(docInfo1);
                                });
                            })];
                    case 2: 
                    // open the document
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    ArrayToGoogleSheets.prototype._addWorkSheet = function (sheetName) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            _this.doc.addWorksheet({ title: sheetName }, function (err, newSheet2) {
                                if (err) {
                                    return reject(err);
                                }
                                resolve(newSheet2);
                            });
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    ArrayToGoogleSheets.prototype._resizeSheet = function (sheet, rowCount, colCount) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        sheet.resize({ rowCount: rowCount, colCount: colCount }, function (err) {
                            if (err) {
                                return reject(err);
                            }
                            resolve();
                        });
                    })];
            });
        });
    };
    ArrayToGoogleSheets.prototype._getCells = function (sheet, maxRow) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        sheet.getCells({
                            "min-row": 1,
                            "max-row": maxRow,
                            "return-empty": true,
                        }, function (err, cells) {
                            if (err) {
                                return reject(err);
                            }
                            resolve(cells);
                        });
                    })];
            });
        });
    };
    ArrayToGoogleSheets.prototype._updateCells = function (sheet, cells) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            sheet.bulkUpdateCells(cells, function (err) {
                                if (err) {
                                    return reject(err);
                                }
                                resolve();
                            });
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return ArrayToGoogleSheets;
}());
exports.ArrayToGoogleSheets = ArrayToGoogleSheets;
